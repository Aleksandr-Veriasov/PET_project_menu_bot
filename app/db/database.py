from __future__ import annotations

import logging
from contextlib import contextmanager
from typing import Generator, Optional

from sqlalchemy import create_engine, text, MetaData
from sqlalchemy.engine import URL, Engine
from sqlalchemy.orm import Session, sessionmaker

from app.core.settings import settings

logger = logging.getLogger(__name__)


class Database:
    """
    –°–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –ë–î –Ω–∞ SQLAlchemy 2.0.

    - –£–ø—Ä–∞–≤–ª—è–µ—Ç sync Engine –∏ Session.
    - –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å –≥–æ—Ç–æ–≤—ã–π Engine (–¥–ª—è —Ç–µ—Å—Ç–æ–≤) –∏–ª–∏ URL (str/URL).
    - URL –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –°–ò–ù–•–†–û–ù–ù–´–ú (postgresql+psycopg2 / postgresql+psycopg).
    """

    def __init__(
        self,
        db_url: Optional[str | URL] = None,
        engine: Optional[Engine] = None,
        *,
        echo: bool = False,
        pool_pre_ping: bool = settings.db.pool_pre_ping,
        pool_recycle: int = settings.db.pool_recycle,
        pool_size: Optional[int] = None,
        max_overflow: Optional[int] = None,
        pool_timeout: Optional[int] = None,
    ) -> None:
        if engine is not None:
            self.engine = engine
            safe = getattr(
                engine.url, "render_as_string", lambda **_: "<engine>"
            )(hide_password=True)
            logger.info("üöÄ DB engine injected: %s", safe)
        else:
            url = db_url or settings.db.sqlalchemy_url()
            # –∑–∞—â–∏—Ç–∞ –æ—Ç async-–¥—Ä–∞–π–≤–µ—Ä–∞ –≤ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–º –∫–ª–∞—Å—Å–µ
            if (isinstance(url, URL) and url.drivername.endswith(
                "+asyncpg"
            )) or (isinstance(url, str) and "asyncpg" in url):
                raise ValueError(
                    "–ü–æ–ª—É—á–µ–Ω async-–¥—Ä–∞–π–≤–µ—Ä (asyncpg) –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ Database."
                    "–°–æ–±–µ—Ä–∏—Ç–µ sync URL (postgresql+psycopg2 / "
                    "postgresql+psycopg)."
                )

            # —Ä–∞–∑—É–º–Ω—ã–µ –¥–µ—Ñ–æ–ª—Ç—ã, –µ—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω—ã –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏
            if echo is None:
                echo = settings.debug
            if pool_pre_ping is None:
                pool_pre_ping = settings.db.pool_pre_ping
            if pool_recycle is None:
                pool_recycle = settings.db.pool_recycle

            engine_kwargs: dict[str, object] = {
                "echo": echo,
                "pool_pre_ping": pool_pre_ping,
                "pool_recycle": pool_recycle,
            }
            if pool_size is not None:
                engine_kwargs["pool_size"] = pool_size
            if max_overflow is not None:
                engine_kwargs["max_overflow"] = max_overflow
            if pool_timeout is not None:
                engine_kwargs["pool_timeout"] = pool_timeout

            self.engine = create_engine(url, **engine_kwargs)

            safe = (
                url.render_as_string(
                    hide_password=True
                ) if isinstance(url, URL) else "<masked url>"
            )
            logger.info("üöÄ DB engine created for %s", safe)

        self._sessionmaker: sessionmaker[Session] = sessionmaker(
            bind=self.engine,
            expire_on_commit=False,
            class_=Session,
        )

    def dispose(self) -> None:
        """–ó–∞–∫—Ä—ã—Ç—å –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ø—É–ª–∞ (–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–∏ shutdown)."""
        self.engine.dispose()
        logger.info("üßπ DB engine disposed")

    def get_session(self) -> Session:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Å–µ—Å—Å–∏—é (–Ω–µ –∑–∞–±—ã–≤–∞–π –∑–∞–∫—Ä—ã—Ç—å!)."""
        logger.debug("üíæ Creating DB session")
        return self._sessionmaker()

    @contextmanager
    def session(self) -> Generator[Session, None, None]:
        """
        –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä —Å –∞–≤—Ç–æ-commit/rollback.

        –ü—Ä–∏–º–µ—Ä:
            with db.session() as session:
                session.add(obj)
        """
        session: Session = self.get_session()
        try:
            yield session
            session.commit()
        except Exception:
            logger.exception("‚ùå Error in async DB session")
            session.rollback()
            raise
        finally:
            session.close()
            logger.debug("üîí Async DB session closed")

    def healthcheck(self) -> bool:
        """–õ—ë–≥–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –ë–î."""
        try:
            with self.engine.connect() as conn:
                conn.execute(text("SELECT 1"))
            return True
        except Exception:
            logger.exception("‚ùå DB healthcheck failed")
            return False

    def create_all(self, base_metadata: MetaData) -> None:
        """
        Bootstrap —Å—Ö–µ–º—ã (dev-only).
        –ü—Ä–∏–º–µ—Ä: db.create_all(Base.metadata)
        """
        with self.engine.begin() as conn:
            base_metadata.create_all(bind=conn)
        logger.info("üì¶ Metadata.create_all() done")
