import asyncio
import logging
from contextlib import asynccontextmanager, suppress
from typing import Optional, cast

from fastapi import FastAPI, HTTPException, Request
from telegram import Update
from telegram.ext import Application

from bot.app.core.types import AppState, PTBApp
from bot.app.handlers.setup import setup_handlers
from packages.common_settings.settings import settings
from packages.db.database import Database
from packages.db.models import Base
from packages.logging_config import setup_logging
from packages.media.video_downloader import cleanup_old_videos
from packages.redis.redis_conn import close_redis, get_redis

setup_logging()
logger = logging.getLogger(__name__)


def build_state() -> AppState:
    return AppState(
        db=Database(
            db_url=settings.db.sqlalchemy_url(),
            echo=settings.debug,
            pool_recycle=settings.db.pool_recycle,
            pool_pre_ping=settings.db.pool_pre_ping,
        ),
        cleanup_task=None,
    )


async def runtime_start(ptb_app: PTBApp, state: AppState) -> None:
    """
    –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (PTB –∏–ª–∏ FastAPI).
    –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –∑–∞–ø—É—Å–∫–∞—Ç—å –¥–æ–ª–≥–æ–∂–∏–≤—É—â–∏–µ –∑–∞–¥–∞—á–∏, –ø–æ–¥–∫–ª—é—á–∞—Ç—å—Å—è –∫ –ë–î –∏ —Ç.–ø.
    """
    logger.info('üöÄ –ó–∞–ø—É—Å–∫ runtime –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏‚Ä¶')
    # –ø—Ä–∏–≤—è–∂–µ–º state –∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é, —á—Ç–æ–±—ã –æ–Ω –±—ã–ª –¥–æ—Å—Ç—É–ø–µ–Ω —Ö–µ–Ω–¥–ª–µ—Ä–∞–º
    ptb_app.bot_data['state'] = state

    # Redis
    state.redis = await get_redis()
    pong = await state.redis.ping()
    logger.info('üß† Redis –ø–æ–¥–∫–ª—é—á—ë–Ω, PING=%s', pong)

    # –§–æ–Ω–æ–≤–∞—è –æ—á–∏—Å—Ç–∫–∞
    logger.info('üöÄ –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É –æ—á–∏—Å—Ç–∫–∏ –≤–∏–¥–µ–æ‚Ä¶')
    state.cleanup_task = asyncio.create_task(cleanup_old_videos())

    # –ë–î: bootstrap (–ø–æ —Ñ–ª–∞–≥—É) –∏ healthcheck
    if settings.db.bootstrap_schema:
        await state.db.create_all(Base.metadata)
    ok = await state.db.healthcheck()
    if not ok:
        raise RuntimeError('DB healthcheck failed at startup')

    # –ï—Å–ª–∏ –≤–∫–ª—é—á—ë–Ω —Ä–µ–∂–∏–º –≤–µ–±—Ö—É–∫–∞ ‚Äî —Å—Ç–∞–≤–∏–º –≤–µ–±—Ö—É–∫ (–≤–∞—Ä–∏–∞–Ω—Ç –ê: –∞–≤—Ç–æ)
    if settings.telegram.use_webhook:
        await ptb_app.bot.set_webhook(
            url=settings.webhooks.url(),
            secret_token=settings.webhooks.secret_token.get_secret_value(),
            drop_pending_updates=True,
            allowed_updates=['message', 'callback_query', 'inline_query'],
        )
        logger.info('üîó Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: %s', settings.webhooks.url())


async def runtime_stop(state: AppState) -> None:
    """
    –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (PTB –∏–ª–∏ FastAPI).
    –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –¥–æ–ª–≥–æ–∂–∏–≤—É—â–∏–µ –∑–∞–¥–∞—á–∏, –æ—Ç–∫–ª—é—á–∞—Ç—å—Å—è –æ—Ç –ë–î –∏ —Ç.–ø.
    """
    # –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ñ–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏
    # –¥–æ—Å—Ç–∞—ë–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –≥–∞—Å–∏–º —Ä–µ—Å—É—Ä—Å—ã
    cur_state: AppState = state.bot_data['state']

    task: Optional[asyncio.Task[None]] = cur_state.cleanup_task
    if task and not task.done():
        logger.info('‚õî –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É‚Ä¶')
        task.cancel()
        with suppress(asyncio.CancelledError):
            await task
        logger.info('‚úÖ –§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.')

    # –ó–∞–∫—Ä—ã—Ç—å Redis
    if cur_state.redis is not None:
        await close_redis()
        cur_state.redis = None
        logger.info('üîí Redis —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∑–∞–∫—Ä—ã—Ç—ã.')

    cur_state.db.dispose()
    logger.info('üîí –°–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ë–î –∑–∞–∫—Ä—ã—Ç—ã.')


def create_ptb_app(attach_ptb_hooks: bool) -> PTBApp:
    """
    –°–æ–∑–¥–∞—ë—Ç –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç PTB Application.
    –ï—Å–ª–∏ attach_ptb_hooks=True, —Ç–æ –Ω–∞–≤–µ—à–∏–≤–∞–µ—Ç —Ö—É–∫–∏ —Å—Ç–∞—Ä—Ç–∞/–æ—Å—Ç–∞–Ω–æ–≤–∫–∏ PTB.
    –ï—Å–ª–∏ attach_ptb_hooks=False, —Ç–æ —Ö—É–∫–∏ –ù–ï –Ω–∞–≤–µ—à–∏–≤–∞—é—Ç—Å—è (—Ç.–∫. –º—ã –∏—Ö
    —Ä–µ–∞–ª–∏–∑—É–µ–º –≤ FastAPI).
    """
    token = settings.telegram.bot_token.get_secret_value().strip()
    if not token:
        raise ValueError('‚ùå TELEGRAM_BOT_TOKEN –ø—É—Å—Ç.')

    # –°–æ–±–∏—Ä–∞–µ–º PTB
    ptb_app = cast(
        PTBApp,
        Application.builder().token(token).build()
    )
    setup_handlers(ptb_app)

    if attach_ptb_hooks:
        state = build_state()

        async def on_startup(app: PTBApp) -> None:
            await runtime_start(app, state)

        async def on_shutdown(app: PTBApp) -> None:
            await runtime_stop(state)

        ptb_app = cast(
            PTBApp,
            Application.builder()
            .token(token)
            .post_init(on_startup)
            .post_shutdown(on_shutdown)
            .build()
        )
        setup_handlers(ptb_app)

    return ptb_app


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è FastAPI-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.
    –ó–¥–µ—Å—å –∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º PTB Application –≤ —Ä–µ–∂–∏–º–µ webhook.
    """
    logger.info('üöÄ –ó–∞–ø—É—Å–∫ webhook-—Å–µ—Ä–≤–µ—Ä–∞ FastAPI‚Ä¶')
    ptb_app: PTBApp = create_ptb_app(attach_ptb_hooks=False)
    state = build_state()

    await ptb_app.initialize()
    await runtime_start(ptb_app, state)
    await ptb_app.start()

    # —Å–æ—Ö—Ä–∞–Ω–∏–º –≤ app.state, —á—Ç–æ–±—ã —Ä–æ—É—Ç—ã –∏–º–µ–ª–∏ –¥–æ—Å—Ç—É–ø
    app.state.ptb_app = ptb_app
    app.state.state = state
    logger.info('‚úÖ PTB Application –∑–∞–ø—É—â–µ–Ω (webhook mode).')

    try:
        yield
    finally:
        logger.info('üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ webhook-—Å–µ—Ä–≤–µ—Ä–∞‚Ä¶')
        await runtime_stop(state)
        await ptb_app.stop()
        await ptb_app.shutdown()
        app.state.ptb_app = None
        app.state.state = None

fastapi_app = FastAPI(title='Telegram Bot Webhook', lifespan=lifespan)


@fastapi_app.post(settings.webhooks.path())
async def telegram_webhook(request: Request) -> dict[str, bool]:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–µ–±—Ö—É–∫–∞ Telegram.
    PTB Application –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è –≤ lifespan FastAPI-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    –∏ —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ app.state.
    """
    ptb_app: PTBApp | None = getattr(request.app.state, 'ptb_app', None)
    if ptb_app is None:
        raise HTTPException(status_code=503, detail='PTB not ready')

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ–∫—Ä–µ—Ç–∞ –æ—Ç Telegram (–∑–∞—â–∏—Ç–∞ –æ—Ç ¬´–ª–µ–≤—ã—Ö¬ª POST)
    secret_hdr = request.headers.get('X-Telegram-Bot-Api-Secret-Token')
    if secret_hdr != settings.webhooks.secret_token.get_secret_value():
        raise HTTPException(status_code=403, detail='Invalid secret token')

    data = await request.json()
    update = Update.de_json(data, ptb_app.bot)
    await ptb_app.update_queue.put(update)
    return {'ok': True}


if __name__ == '__main__':
    if not settings.telegram.use_webhook:
        # –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º: polling
        try:
            application = create_ptb_app(attach_ptb_hooks=True)
            logger.info('ü§ñ –ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è (polling)‚Ä¶')
            application.run_polling(
                poll_interval=1.0,
                drop_pending_updates=True,
            )
        except Exception:
            logger.exception('üî• –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞ (polling)')
            raise
    else:
        # –†–µ–∂–∏–º –≤–µ–±—Ö—É–∫–∞: –ø–æ–¥–Ω–∏–º–∞–µ–º FastAPI-—Å–µ—Ä–≤–µ—Ä –≤–Ω—É—Ç—Ä–∏ —ç—Ç–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
        import uvicorn
        port = settings.webhooks.port
        logger.info('üåê –ó–∞–ø—É—Å–∫ webhook-—Å–µ—Ä–≤–µ—Ä–∞ FastAPI –Ω–∞ –ø–æ—Ä—Ç—É %s', port)
        uvicorn.run(
            fastapi_app,
            host='0.0.0.0',
            port=port,
            # reload –Ω–µ –Ω—É–∂–µ–Ω –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ
            workers=settings.fast_api.uvicorn_workers,
            log_level='info',
        )
